import ast
from sys import argv

def parse_args(x):
    return [f'{Compiler([arg.annotation]).compile()} {arg.arg}' for arg in x]


boilerplate = r"""// Generated by cpp.py
#include <cstdio>
#include <string>
#include <cstdarg>

#define print printf
#define str   std::string   
/* Start */
"""

#  import [libc].<ext no | any>.<filename>
class Module:
    def __init__(self, mod):
        self.mod = mod
        temp = mod.split('.')
        out = False
        if temp[0] == 'libc':
            out = True
            temp = temp[1:]

        ext = temp[0]
        temp = temp[1:]

        if ext == 'no':
            self.filename = f'{"/".join(temp)}'
        else:
            self.filename = f'{"/".join(temp)}.{ext}'

        self.b1 = '<' if out else '"'
        self.b2 = '>' if out else '"'

    def view(self):
        return f"#include {self.b1}{self.filename}{self.b2}\n"


class CPPFile:
    def __init__(self):
        self.out = ''

    def append(self, x):
        self.out += x

    def write(self, out='out.cpp'):
        with open(out, 'w') as f:
            f.write(self.strip_excess())

    def strip_excess(self):
        return self.out.rstrip()


def tab(x): return '\n'.join(['    ' + y for y in x.split('\n')]).rstrip()


variables = {}


class Compiler:
    def __init__(self, pyast):
        self.pos = 0
        self.ast = pyast
        self.cppfile = CPPFile()
        self.cppfile.append(boilerplate)

    def errast(self, node, msg):
        print(f'[compiler {node.lineno}:{node.col_offset}]: {msg}')

    def extract(self, if_stmt, elseifs, else_):
        for i in if_stmt.orelse:
            if isinstance(i, ast.If):
                test = self.isocompile([i.test])
                elbody = self.isocompile(i.body)
                elseifs.append([test, elbody])
                if i.orelse != []:
                    self.extract(i, elseifs, else_)
            else:
                else_.append(self.isocompile(if_stmt.orelse))
                return

    def handleop(self, x, y, z):
        if isinstance(x, ast.Add):
            return f'{y} + {z}'
        elif isinstance(x, ast.Sub):
            return f'{y} - {z}'
        elif isinstance(x, ast.Mult):
            return f'{y} * {z}'
        elif isinstance(x, ast.Div):
            return f'{y} / {z}'
        elif isinstance(x, ast.Mod):
            return f'{y} % {z}'
        print(f'[error]: unknown operator {x}')
        quit(1)

    def cmp(self, x, y, z):
        op = ''
        if isinstance(x, ast.Eq):
            op = '=='
        elif isinstance(x, ast.NotEq):
            op = '!='
        elif isinstance(x, ast.Gt):
            op = '>'
        elif isinstance(x, ast.GtE):
            op = '>='
        elif isinstance(x, ast.Lt):
            op = '<'
        elif isinstance(x, ast.LtE):
            op = '<='

        if op != '':
            return f'{y} {op} {z}'
        else:
            print(f'[error]: unknown CMP-operator {x}')
            quit(1)

    def compile(self):
        end = ''

        while not self.at_end():
            if self.inst(ast.AnnAssign):
                var_ = self.peek()
                name = self.isocompile([var_.target])
                typ = self.isocompile([var_.annotation])
                if var_.value:
                    end += f'{typ} {name} = {self.isocompile([var_.value])};\n'
                else:
                    end += f'{typ} {name};\n'

            elif self.inst(ast.Assign):
                var_ = self.peek()
                name = self.isocompile([var_.targets[0]])
                end += f'{name} = {self.isocompile([var_.value])};\n'

            elif self.inst(ast.Constant):
                const = self.peek()
                if isinstance(const.value, str):
                    value = const.value \
                        .replace("\n", "\\n") \
                        .replace("\r", "\\r")
                    end += f'"{value}"'
                elif isinstance(const.value, bool):
                    end += f'{str(const.value).lower()}'
                else:
                    end += str(const.value)

            elif self.inst(ast.Dict):
                pass

            elif self.inst(ast.Subscript):
                sub = self.peek()
                value = self.isocompile([sub.value])
                slice = self.isocompile([sub.slice])
                end += f'{value}[{slice}]'

            elif self.inst(ast.For):
                pass

            elif self.inst(ast.AugAssign):
                var = self.peek()
                target = self.isocompile([var.target])
                end += f'{target} += {self.isocompile([var.value])};\n'

            elif self.inst(ast.BinOp):
                binop = self.peek()
                left = self.isocompile([binop.left])
                op = binop.op
                right = self.isocompile([binop.right])

                end += self.handleop(op, left, right)

            elif self.inst(ast.Name):
                end += self.peek().id

            elif self.inst(ast.Expr):
                expr = self.isocompile([self.peek().value])
                end += f'{expr};\n'

            elif self.inst(ast.Call):
                fn = self.peek()
                name = self.isocompile([fn.func])
                args = [self.isocompile([x]) for x in fn.args]

                if name == '__cpp__':
                    if [(x[0] == '"' and x[-1] == '"') or (x[0] == "'" and x[-1] == "'") for x in args] != [True] * len(args):
                        self.errast("__cpp__ only accepts string arguments")
                    inline = '\n'.join([x[1:-1] for x in args])
                    if inline.endswith(';'):
                        end += inline[:-1]
                    else: end += inline
                    
                elif name == '__asm__':
                    if [(x[0] == '"' and x[-1] == '"') or (x[0] == "'" and x[-1] == "'") for x in args] != [True] * len(args):
                        self.errast("__cpp__ only accepts string arguments")
                    inline = '\n'+',\n'.join(args)
                
                    end += f'asm({tab(inline)})'
                    
                else:
                    end += f'{name}({", ".join(args)})'

            elif self.inst(ast.While):
                while_ = self.peek()
                test = self.isocompile([while_.test])
                body = self.isocompile(while_.body)
                end += f"while ({test}) {{\n{tab(body)}\n}}\n"

            elif self.inst(ast.Return):
                end += f'return {self.isocompile([self.peek().value])};\n'

            elif self.inst(ast.Attribute):
                attr = self.peek()
                name = self.isocompile([attr.value])
                end += f'{name}.{attr.attr}'

            elif self.inst(ast.Import):
                import_ = self.peek()
                name = Module(import_.names[0].name)
                end += name.view()

            elif self.inst(ast.Compare):
                cmp = self.peek()
                left = self.isocompile([cmp.left])
                right = self.isocompile([cmp.comparators[0]])
                op = self.cmp(cmp.ops[0], left, right)
                end += op

            elif self.inst(ast.List):
                pass

            elif self.inst(ast.If):
                If = self.peek()
                test = self.isocompile([If.test])
                body = self.isocompile(If.body)
                elseifs = []
                else_ = []
                self.extract(If, elseifs, else_)
                end += f'if ({test}) {{\n{tab(body)}\n}} '
                for eif in elseifs:
                    end += f'elseif ({eif[0]}) {{\n{tab(self.isocompile(eif[1]))}\n}} '
                if len(else_) > 0:
                    end += f'else {{\n{tab(self.isocompile(else_[0]))}\n}}'
                end += '\n'

            elif self.inst(ast.FunctionDef):
                fn_def = self.peek()
                name = fn_def.name
                if name.startswith("cppmacro_"):
                    args = ', '.join([self.isocompile([x]) for x in fn_def.args.args])
                    body = ' \\\n'.join(self.isocompile(fn_def.body).split('\n'))
                    end += f"#define {name}({args}) do {{ \\\n{tab(body)}\n}} while (false);\n"
                else:
                    args = parse_args(fn_def.args.args)
                    returns = self.isocompile([fn_def.returns])
                    body = self.isocompile(fn_def.body)

                    end += f'{returns} {name}({", ".join(args)}) {{\n{tab(body)}\n}}\n'

            elif self.inst(ast.ClassDef):
                klass = self.peek()
                name = klass.name

                end += f"class {name} {{\npublic:\n{tab(self.isocompile(klass.body))}\n}};\n"

            elif self.inst(ast.UnaryOp):
                un = self.peek()
                op = un.op
                value = self.isocompile([un.operand])
                if isinstance(op, ast.USub):
                    end += f'-{value}'

            self.advance()

        return end
    # ----------
    # | Utils  |
    # ----------

    def isocompile(self, *args):
        return Compiler(*args).compile()

    def inst(self, x):
        return isinstance(self.peek(), x)

    def advance(self):
        self.pos += 1

    def at_end(self):
        return self.pos >= len(self.ast)

    def devance(self):
        self.pos -= 1

    def add(self, item):
        self.cppfile.append(item)

    def write(self):
        self.cppfile.write()

    def peek(self):
        return self.ast[self.pos]

    def prev(self):
        return self.ast[self.pos-1]


def gen_ast(x):
    tree = ast.parse(open(x).read())
    return tree.body


def compile_file(x):
    compiler = Compiler(gen_ast(x))

    compiler.add(compiler.compile())
    compiler.write()


if len(argv) <= 1:
    print('usage: ./c.py <FILE>')
    quit(1)

file = argv[1]
compile_file(file)